{
  "type": "excalidraw",
  "version": 2,
  "source": "https://excalidraw.com",
  "elements": [
    {
      "type": "text",
      "version": 5,
      "versionNonce": 243962181,
      "index": "a3",
      "isDeleted": false,
      "id": "yLg_CjFly4eW9eXhSnyhv",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 347.20001220703125,
      "y": 133.40000915527344,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 928.203125,
      "height": 529,
      "seed": 1584020683,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1714216844704,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 2,
      "text": "void dfs(int n, int m, int x, int y, int p, int t, vector<vector<int>> &image, vector<vector<int>> &vis) {\n    vis[x][y] = 1;\n    image[x][y] = p;\n    int delcol[4] = {-1, 0, 1, 0};\n    int delrow[4] = {0, 1, 0, -1};\n\n    for (int i = 0; i < 4; i++) {\n        int nrow = x + delrow[i];\n        int ncol = y + delcol[i];\n\n        if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && !vis[nrow][ncol] && image[nrow][ncol] == t) {\n            dfs(n, m, nrow, ncol, p, t, image, vis);\n        }\n    }\n}\n\nvector<vector<int>> floodFill(vector<vector<int>> &image, int n, int m, int x, int y, int p) {\n    vector<vector<int>> vis(n, vector<int>(m, 0));\n    int t = image[x][y];\n\n    dfs(n, m, x, y, p, t, image, vis);\n    return image;  // Return the modified image matrix\n}",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "void dfs(int n, int m, int x, int y, int p, int t, vector<vector<int>> &image, vector<vector<int>> &vis) {\n    vis[x][y] = 1;\n    image[x][y] = p;\n    int delcol[4] = {-1, 0, 1, 0};\n    int delrow[4] = {0, 1, 0, -1};\n\n    for (int i = 0; i < 4; i++) {\n        int nrow = x + delrow[i];\n        int ncol = y + delcol[i];\n\n        if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && !vis[nrow][ncol] && image[nrow][ncol] == t) {\n            dfs(n, m, nrow, ncol, p, t, image, vis);\n        }\n    }\n}\n\nvector<vector<int>> floodFill(vector<vector<int>> &image, int n, int m, int x, int y, int p) {\n    vector<vector<int>> vis(n, vector<int>(m, 0));\n    int t = image[x][y];\n\n    dfs(n, m, x, y, p, t, image, vis);\n    return image;  // Return the modified image matrix\n}",
      "lineHeight": 1.15
    },
    {
      "type": "text",
      "version": 20,
      "versionNonce": 410389451,
      "index": "a4",
      "isDeleted": false,
      "id": "tkQRphDZli9XVP_qwgmar",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 616,
      "y": 25.399993896484375,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "width": 359.7118835449219,
      "height": 45,
      "seed": 89382379,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1714214385703,
      "link": null,
      "locked": false,
      "fontSize": 36,
      "fontFamily": 1,
      "text": "FLOOD FILL ALGO ",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "FLOOD FILL ALGO ",
      "lineHeight": 1.25
    },
    {
      "type": "text",
      "version": 21,
      "versionNonce": 924156299,
      "index": "a5",
      "isDeleted": false,
      "id": "uRYJNnd0EIcNjOz_vs29l",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 608.7999877929688,
      "y": 842.8000183105469,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "width": 281.4478759765625,
      "height": 180,
      "seed": 897045771,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1714216795955,
      "link": null,
      "locked": false,
      "fontSize": 36,
      "fontFamily": 1,
      "text": "cycle detection \n\n\n",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "cycle detection \n\n\n",
      "lineHeight": 1.25
    },
    {
      "type": "text",
      "version": 5,
      "versionNonce": 65259461,
      "index": "a6",
      "isDeleted": false,
      "id": "fNrS4ERl7lJ62UTeupmRK",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 376,
      "y": 914.8000183105469,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 703.125,
      "height": 1008,
      "seed": 1482613771,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1714216856961,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 3,
      "text": "#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Graph {\npublic:\n    bool bfs(int src, vector<int> adj[], vector<int> &vis) {\n        queue<pair<int, int>> q;\n        q.push({src, -1});\n        vis[src] = 1;\n        \n        while (!q.empty()) {\n            int node = q.front().first;\n            int parent = q.front().second;\n            q.pop();\n\n            for (int it : adj[node]) {\n                if (!vis[it]) {\n                    vis[it] = 1;\n                    q.push({it, node});\n                } else if (it != parent) {\n                    return true;  // Cycle detected\n                }\n            }\n        }\n        return false;  // No cycle found\n    }\n\n    bool detectCycle(int V, vector<int> adj[]) {\n        vector<int> vis(V, 0);\n\n        for (int i = 0; i < V; i++) {\n            if (!vis[i]) {\n                if (bfs(i, adj, vis)) {\n                    return true;  // Cycle detected\n                }\n            }\n        }\n        return false;  // No cycle found\n    }\n};\n",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Graph {\npublic:\n    bool bfs(int src, vector<int> adj[], vector<int> &vis) {\n        queue<pair<int, int>> q;\n        q.push({src, -1});\n        vis[src] = 1;\n        \n        while (!q.empty()) {\n            int node = q.front().first;\n            int parent = q.front().second;\n            q.pop();\n\n            for (int it : adj[node]) {\n                if (!vis[it]) {\n                    vis[it] = 1;\n                    q.push({it, node});\n                } else if (it != parent) {\n                    return true;  // Cycle detected\n                }\n            }\n        }\n        return false;  // No cycle found\n    }\n\n    bool detectCycle(int V, vector<int> adj[]) {\n        vector<int> vis(V, 0);\n\n        for (int i = 0; i < V; i++) {\n            if (!vis[i]) {\n                if (bfs(i, adj, vis)) {\n                    return true;  // Cycle detected\n                }\n            }\n        }\n        return false;  // No cycle found\n    }\n};\n",
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 20,
      "versionNonce": 2027341387,
      "index": "a8",
      "isDeleted": false,
      "id": "K4-j5IJrp4B5-w2LOQVSj",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 546.4000244140625,
      "y": 2001.7999938964845,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "width": 216.21595764160156,
      "height": 45,
      "seed": 562735531,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1714219110389,
      "link": null,
      "locked": false,
      "fontSize": 36,
      "fontFamily": 1,
      "text": "0/1 MATRIX",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "0/1 MATRIX",
      "lineHeight": 1.25
    },
    {
      "type": "text",
      "version": 3,
      "versionNonce": 1262122859,
      "index": "a9",
      "isDeleted": false,
      "id": "HgettielFkY7EMmLPfP65",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 396,
      "y": 2093,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 1019.53125,
      "height": 840,
      "seed": 727434795,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1714219126996,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 3,
      "text": "vector < vector < int > > nearest(vector < vector < int >> & mat, int n, int m) {\n    vector<vector<int>> vis(n,vector<int>(m,0));\n    vector<vector<int>> dist(n,vector<int>(m,0));\n    queue<pair<pair<int,int>,int>> q;\n    \n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            if(mat[i][j] == 1){\n                q.push({{i,j},0});\n                vis[i][j] = 1;\n            }\n            else vis[i][j] = 0;\n        }\n    }\n    \n    int delrow[] = {-1,0,+1,0};\n    int delcol[] = {0,+1,0,-1};\n    \n    while(!q.empty()){\n        int row = q.front().first.first;\n        int col = q.front().first.second;\n        int step = q.front().second;\n        q.pop();\n        dist[row][col] = step;\n        for(int i = 0; i < 4; i++){\n            int nrow = row + delrow[i];\n            int ncol = col + delcol[i];\n            if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && vis[nrow][ncol] == 0){\n                vis[nrow][ncol] = 1;\n                q.push({{nrow,ncol},step+1});\n            }\n        }\n    }\n    return dist;\n}",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "vector < vector < int > > nearest(vector < vector < int >> & mat, int n, int m) {\n    vector<vector<int>> vis(n,vector<int>(m,0));\n    vector<vector<int>> dist(n,vector<int>(m,0));\n    queue<pair<pair<int,int>,int>> q;\n    \n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            if(mat[i][j] == 1){\n                q.push({{i,j},0});\n                vis[i][j] = 1;\n            }\n            else vis[i][j] = 0;\n        }\n    }\n    \n    int delrow[] = {-1,0,+1,0};\n    int delcol[] = {0,+1,0,-1};\n    \n    while(!q.empty()){\n        int row = q.front().first.first;\n        int col = q.front().first.second;\n        int step = q.front().second;\n        q.pop();\n        dist[row][col] = step;\n        for(int i = 0; i < 4; i++){\n            int nrow = row + delrow[i];\n            int ncol = col + delcol[i];\n            if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m && vis[nrow][ncol] == 0){\n                vis[nrow][ncol] = 1;\n                q.push({{nrow,ncol},step+1});\n            }\n        }\n    }\n    return dist;\n}",
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 20,
      "versionNonce": 531637371,
      "index": "aA",
      "isDeleted": false,
      "id": "_mhCi7eZ7GF0r34jE0DHy",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 512.4559783935547,
      "y": 2996.699996948242,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "width": 189.84375,
      "height": 43.199999999999996,
      "seed": 514980475,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1714384325123,
      "link": null,
      "locked": false,
      "fontSize": 36,
      "fontFamily": 3,
      "text": "BIPARTITE",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "BIPARTITE",
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 4,
      "versionNonce": 2046748917,
      "index": "aB",
      "isDeleted": false,
      "id": "6YCH3z1JXfnwJiIwN571-",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 380.45594787597656,
      "y": 3106.2999877929688,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 2191.40625,
      "height": 1224,
      "seed": 2011533915,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1714384694509,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 3,
      "text": "#include <bits/stdc++.h>\n\n\nbool isGraphBirpatite(vector<vector<int>> &edges) {\n\t// Write your code here.\n\t// Variable for row and column\n\tint n = edges.size();\n\tint m = edges[0].size(); \n\t//Queue for BFS\n\tqueue <int> q;\n\t//Array to mark the color of the nodes\n\tvector<int> vis(n,-1);\n\n\n\t//Creating adjacency list from the matrix\n\tvector<vector<int>> adj(n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(edges[i][j]==1){\n\t\t\t\tadj[i].push_back(j);\n\t\t\t\tadj[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\t//Initial source is 0 so pushing it and marking its color as 0\n\tq.push(0);\n\tvis[0]=0;\n\n\t//BFS Traversal starts\n\twhile(!q.empty()){\n\t\tint u = q.front();\n\t\tq.pop();\n\n\t\t//Traversing each node's adjacency list\n\t\tfor(auto x:adj[u]){\n\t\t\t//If it is not colored then coloring it with the opposite color of the actual node\n\t\t\tif(vis[x]==-1){\n\t\t\t\tvis[x]=!vis[u];\n\t\t\t\t//Then pushing it in the queue for later traversal of that node\n\t\t\t\tq.push(x);\n\t\t\t}\n\t\t\t//If it is already colored as the same color of the actual node that means it might have been colored using some other path and therefore it can never be bipartite\n\t\t\telse if(vis[x]==vis[u]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t//If after the loop the return false doesnt execute that means its a bipartite\n\treturn true;\n}",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "#include <bits/stdc++.h>\n\n\nbool isGraphBirpatite(vector<vector<int>> &edges) {\n\t// Write your code here.\n\t// Variable for row and column\n\tint n = edges.size();\n\tint m = edges[0].size(); \n\t//Queue for BFS\n\tqueue <int> q;\n\t//Array to mark the color of the nodes\n\tvector<int> vis(n,-1);\n\n\n\t//Creating adjacency list from the matrix\n\tvector<vector<int>> adj(n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(edges[i][j]==1){\n\t\t\t\tadj[i].push_back(j);\n\t\t\t\tadj[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\t//Initial source is 0 so pushing it and marking its color as 0\n\tq.push(0);\n\tvis[0]=0;\n\n\t//BFS Traversal starts\n\twhile(!q.empty()){\n\t\tint u = q.front();\n\t\tq.pop();\n\n\t\t//Traversing each node's adjacency list\n\t\tfor(auto x:adj[u]){\n\t\t\t//If it is not colored then coloring it with the opposite color of the actual node\n\t\t\tif(vis[x]==-1){\n\t\t\t\tvis[x]=!vis[u];\n\t\t\t\t//Then pushing it in the queue for later traversal of that node\n\t\t\t\tq.push(x);\n\t\t\t}\n\t\t\t//If it is already colored as the same color of the actual node that means it might have been colored using some other path and therefore it can never be bipartite\n\t\t\telse if(vis[x]==vis[u]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t//If after the loop the return false doesnt execute that means its a bipartite\n\treturn true;\n}",
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 27,
      "versionNonce": 701341877,
      "index": "aC",
      "isDeleted": false,
      "id": "GFMT5LhXbd0zCyzHyokHW",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 661.0559539794922,
      "y": 4414.299987792969,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "width": 358.59375,
      "height": 43.199999999999996,
      "seed": 1716973493,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1714384735899,
      "link": null,
      "locked": false,
      "fontSize": 36,
      "fontFamily": 3,
      "text": "DISTINCT ICELAND ",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "DISTINCT ICELAND ",
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 3,
      "versionNonce": 13209493,
      "index": "aD",
      "isDeleted": false,
      "id": "ZDrQPjdrVZHJeXTJsD8k4",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 513.8559417724609,
      "y": 4503.899993896484,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 515.625,
      "height": 912,
      "seed": 1630404821,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1714384769376,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 3,
      "text": "#include<bits/stdc++.h>\nvoid dfs(int r,int c,int n,int m,int rbase,\nint cbase,vector<vector<int>>&vis,\nvector<pair<int,int>>&temp,int** arr)\n{\n    vis[r][c]=1;\n    temp.push_back({r-rbase,c-cbase});\n    int drow[]={-1,0,1,0};\n    int dcol[]={0,-1,0,1};\n\n    for(int i=0;i<4;i++)\n    {\n        int nr=r+drow[i];\n        int nc=c+dcol[i];\n\n        if(0<=nr && nr<n && 0<=nc && nc<m &&\n         !vis[nr][nc] && arr[nr][nc]==1)\n        {\n    dfs(nr,nc,n,m,rbase,cbase,vis,temp,arr);\n        }\n    }\n}\nint distinctIslands(int** arr, int n, int m)\n{\n    set<vector<pair<int,int>>>distinct;\nvector<vector<int>>vis(n,vector<int>(m,0));\n    for(int i=0;i<n;i++)\n       for(int j=0;j<m;j++)\n           if(!vis[i][j] && arr[i][j]==1)\n            {\n                vector<pair<int,int>>temp;\n              dfs(i,j,n,m,i,j,vis,temp,arr);\n                distinct.insert(temp);\n            }\n\n    return distinct.size();\n}\n",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "#include<bits/stdc++.h>\nvoid dfs(int r,int c,int n,int m,int rbase,\nint cbase,vector<vector<int>>&vis,\nvector<pair<int,int>>&temp,int** arr)\n{\n    vis[r][c]=1;\n    temp.push_back({r-rbase,c-cbase});\n    int drow[]={-1,0,1,0};\n    int dcol[]={0,-1,0,1};\n\n    for(int i=0;i<4;i++)\n    {\n        int nr=r+drow[i];\n        int nc=c+dcol[i];\n\n        if(0<=nr && nr<n && 0<=nc && nc<m &&\n         !vis[nr][nc] && arr[nr][nc]==1)\n        {\n    dfs(nr,nc,n,m,rbase,cbase,vis,temp,arr);\n        }\n    }\n}\nint distinctIslands(int** arr, int n, int m)\n{\n    set<vector<pair<int,int>>>distinct;\nvector<vector<int>>vis(n,vector<int>(m,0));\n    for(int i=0;i<n;i++)\n       for(int j=0;j<m;j++)\n           if(!vis[i][j] && arr[i][j]==1)\n            {\n                vector<pair<int,int>>temp;\n              dfs(i,j,n,m,i,j,vis,temp,arr);\n                distinct.insert(temp);\n            }\n\n    return distinct.size();\n}\n",
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 27,
      "versionNonce": 1891221832,
      "index": "aE",
      "isDeleted": false,
      "id": "h7prrL4uyy0my8PTBI8cj",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 652.1893056233724,
      "y": 5507.466683451333,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "width": 189.84375,
      "height": 86.39999999999999,
      "seed": 964755514,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1715500606952,
      "link": null,
      "locked": false,
      "fontSize": 36,
      "fontFamily": 3,
      "text": "TOPOSORT \n",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "TOPOSORT \n",
      "lineHeight": 1.2
    },
    {
      "id": "CYXqBgbIfJi30aQ1HOSWb",
      "type": "text",
      "x": 312.0559539794922,
      "y": 5633.100021362305,
      "width": 960.9375,
      "height": 912,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aF",
      "roundness": null,
      "seed": 371037894,
      "version": 9,
      "versionNonce": 598499142,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1715504254088,
      "link": null,
      "locked": false,
      "text": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    void dfs(vector<int>& vis, vector<vector<int>>& adj, stack<int>& s, int src) {\n        vis[src] = 1;\n        for (auto it : adj[src]) {\n            if (!vis[it]) {\n                dfs(vis, adj, s, it);\n            }\n        }\n        s.push(src);\n    }\n\n    vector<int> topoSort(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<int> ans;\n        stack<int> s;\n        vector<int> vis(numCourses, 0);\n        vector<vector<int>> adj(numCourses);\n\n        for (auto pre : prerequisites) {\n            adj[pre[1]].push_back(pre[0]);\n        }\n\n        for (int i = 0; i < numCourses; i++) {\n            if (!vis[i]) {\n                dfs(vis, adj, s, i);\n            }\n        }\n        while (!s.empty()) {\n            ans.push_back(s.top());\n            s.pop();\n        }\n        return ans;\n    }\n};\n",
      "fontSize": 20,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    void dfs(vector<int>& vis, vector<vector<int>>& adj, stack<int>& s, int src) {\n        vis[src] = 1;\n        for (auto it : adj[src]) {\n            if (!vis[it]) {\n                dfs(vis, adj, s, it);\n            }\n        }\n        s.push(src);\n    }\n\n    vector<int> topoSort(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<int> ans;\n        stack<int> s;\n        vector<int> vis(numCourses, 0);\n        vector<vector<int>> adj(numCourses);\n\n        for (auto pre : prerequisites) {\n            adj[pre[1]].push_back(pre[0]);\n        }\n\n        for (int i = 0; i < numCourses; i++) {\n            if (!vis[i]) {\n                dfs(vis, adj, s, i);\n            }\n        }\n        while (!s.empty()) {\n            ans.push_back(s.top());\n            s.pop();\n        }\n        return ans;\n    }\n};\n",
      "lineHeight": 1.2
    },
    {
      "id": "VZYP5byzX9bOxrSAsKv0m",
      "type": "text",
      "x": 708.8559417724609,
      "y": 6635.699996948242,
      "width": 253.125,
      "height": 43.199999999999996,
      "angle": 0,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aG",
      "roundness": null,
      "seed": 42133146,
      "version": 22,
      "versionNonce": 434459270,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1715504089475,
      "link": null,
      "locked": false,
      "text": "kahn's algo ",
      "fontSize": 36,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "kahn's algo ",
      "lineHeight": 1.2
    },
    {
      "id": "LZGBNIItusCqT_40eDvXo",
      "type": "text",
      "x": 340.85594177246094,
      "y": 6748.5,
      "width": 750,
      "height": 936,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aI",
      "roundness": null,
      "seed": 953845062,
      "version": 3,
      "versionNonce": 1308781510,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1715504226970,
      "link": null,
      "locked": false,
      "text": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> topoSort(int V, vector<int> adj[]) {\n        vector<int> ans;\n        queue<int> q; // Renamed from s to q for clarity\n        \n        int ind[V] = {0};\n        \n        for (int i = 0; i < V; i++) {\n            for (auto it : adj[i]) {\n                ind[it]++;\n            }\n        }\n        \n        for (int i = 0; i < V; i++) {\n            if (ind[i] == 0) {\n                q.push(i);\n            }\n        }\n        \n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            ans.push_back(node); // Add the node to ans directly\n            \n            for (auto it : adj[node]) {\n                ind[it]--;\n                if (ind[it] == 0) {\n                    q.push(it);\n                }\n            }\n        }\n        return ans;\n    }\n};\n",
      "fontSize": 20,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> topoSort(int V, vector<int> adj[]) {\n        vector<int> ans;\n        queue<int> q; // Renamed from s to q for clarity\n        \n        int ind[V] = {0};\n        \n        for (int i = 0; i < V; i++) {\n            for (auto it : adj[i]) {\n                ind[it]++;\n            }\n        }\n        \n        for (int i = 0; i < V; i++) {\n            if (ind[i] == 0) {\n                q.push(i);\n            }\n        }\n        \n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            ans.push_back(node); // Add the node to ans directly\n            \n            for (auto it : adj[node]) {\n                ind[it]--;\n                if (ind[it] == 0) {\n                    q.push(it);\n                }\n            }\n        }\n        return ans;\n    }\n};\n",
      "lineHeight": 1.2
    }
  ],
  "appState": {
    "gridSize": null,
    "viewBackgroundColor": "#ffffff"
  },
  "files": {}
}