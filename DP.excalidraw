{
  "type": "excalidraw",
  "version": 2,
  "source": "https://excalidraw.com",
  "elements": [
    {
      "type": "text",
      "version": 102,
      "versionNonce": 15560590,
      "index": "a2",
      "isDeleted": false,
      "id": "mFHQ53oydsvLfy-glb8vM",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 381.26911320627926,
      "y": 0.9311708944329666,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 972.65625,
      "height": 648,
      "seed": 265813117,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1720667465667,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 3,
      "text": "#include <iostream>\n#include <vector>\n\nvoid printSubsets(int ind, const std::vector<int>& arr, std::vector<int>& subset) {\n    if (ind == arr.size()) {\n        for (int num : subset) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n        return;\n    }\n\n    // Include the current element\n    subset.push_back(arr[ind]);\n    printSubsets(ind + 1, arr, subset);\n    subset.pop_back();\n\n    // Exclude the current element\n    printSubsets(ind + 1, arr, subset);\n}\n\nint main() {\n    std::vector<int> input = {1, 2, 3};\n    std::vector<int> subset;\n    printSubsets(0, input, subset);\n    return 0;\n}",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "#include <iostream>\n#include <vector>\n\nvoid printSubsets(int ind, const std::vector<int>& arr, std::vector<int>& subset) {\n    if (ind == arr.size()) {\n        for (int num : subset) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n        return;\n    }\n\n    // Include the current element\n    subset.push_back(arr[ind]);\n    printSubsets(ind + 1, arr, subset);\n    subset.pop_back();\n\n    // Exclude the current element\n    printSubsets(ind + 1, arr, subset);\n}\n\nint main() {\n    std::vector<int> input = {1, 2, 3};\n    std::vector<int> subset;\n    printSubsets(0, input, subset);\n    return 0;\n}",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 27,
      "versionNonce": 711108097,
      "index": "a3",
      "isDeleted": false,
      "id": "ZRIBMu4lviYrPM0yFvu6h",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 514.6969514643645,
      "y": -185.5510621501581,
      "strokeColor": "#2f9e44",
      "backgroundColor": "transparent",
      "width": 379.6875,
      "height": 43.199999999999996,
      "seed": 307697043,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1720458443956,
      "link": null,
      "locked": false,
      "fontSize": 36,
      "fontFamily": 3,
      "text": "DYNAMIC PROGRAMING",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "DYNAMIC PROGRAMING",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 64,
      "versionNonce": 520320655,
      "index": "a5",
      "isDeleted": false,
      "id": "vxzs0eRrMyO_BqviFVrlo",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 390.3257340423381,
      "y": -49.358899873741336,
      "strokeColor": "#2f9e44",
      "backgroundColor": "transparent",
      "width": 597.65625,
      "height": 24,
      "seed": 59812627,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1720458443956,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 3,
      "text": "INCLUDE AND EXCLUDE ALGO (TO FIND ALL SUBSEQUENCES)",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "INCLUDE AND EXCLUDE ALGO (TO FIND ALL SUBSEQUENCES)",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 9,
      "versionNonce": 1577074145,
      "index": "a6",
      "isDeleted": false,
      "id": "JvJ-BtrEHhcFXL9ytNuF4",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 282.6113806351111,
      "y": 800.1411648810338,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 1125,
      "height": 648,
      "seed": 1912871837,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1720458443956,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 3,
      "text": "#include <iostream>\n#include <vector>\nusing namespace std;\nint printSubsets(int ind, const std::vector<int>& arr, std::vector<int>& subset,int sum,int s) {\n    if (ind == arr.size()) {\n        if(s==sum){\n            return 1;\n        }\n        return 0;\n    }\n    \n    s+=arr[ind];\n    \n    int l = printSubsets(ind + 1, arr, subset,sum,s);\n    s-=arr[ind];\n    int r = printSubsets(ind + 1, arr, subset,sum,s);\n    \n    return l+r;\n}\n\nint main() {\n    std::vector<int> input = {1, 2, 3};\n    std::vector<int> subset;\n    int sum = 2;\n    cout<<printSubsets(0, input, subset,sum,0);\n    return 0;\n}",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "#include <iostream>\n#include <vector>\nusing namespace std;\nint printSubsets(int ind, const std::vector<int>& arr, std::vector<int>& subset,int sum,int s) {\n    if (ind == arr.size()) {\n        if(s==sum){\n            return 1;\n        }\n        return 0;\n    }\n    \n    s+=arr[ind];\n    \n    int l = printSubsets(ind + 1, arr, subset,sum,s);\n    s-=arr[ind];\n    int r = printSubsets(ind + 1, arr, subset,sum,s);\n    \n    return l+r;\n}\n\nint main() {\n    std::vector<int> input = {1, 2, 3};\n    std::vector<int> subset;\n    int sum = 2;\n    cout<<printSubsets(0, input, subset,sum,0);\n    return 0;\n}",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 43,
      "versionNonce": 798215343,
      "index": "a7",
      "isDeleted": false,
      "id": "KRXjTLMLPomj915RFzN_v",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 279.2799739436747,
      "y": 752.3914965107276,
      "strokeColor": "#2f9e44",
      "backgroundColor": "transparent",
      "width": 445.3125,
      "height": 24,
      "seed": 1628311571,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1720458443956,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 3,
      "text": "SUM OF THE SUBSEQUENCES WHOSE SUM IS K",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "SUM OF THE SUBSEQUENCES WHOSE SUM IS K",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 7,
      "versionNonce": 501209537,
      "index": "a8",
      "isDeleted": false,
      "id": "wuP2lptCWjtDAKuIQNQA2",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 283.72182129185944,
      "y": 1546.3686812161711,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 632.8125,
      "height": 600,
      "seed": 1973269235,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1720458443956,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 3,
      "text": "class Solution{\npublic:\t\nint solve(int *arr, int i,int n,vector<int> &dp){\n    if(i==0){\n        return arr[i];\n    }\n    if(i<0){\n        return 0;\n    }\n    if(dp[i]!=-1){\n        return dp[i];\n    }\n    \n    int pick = arr[i]+solve(arr,i-2,n,dp);\n    int not_pick = 0+solve(arr,i-1,n,dp);\n    \n    return max(pick,not_pick);\n}\n\t// calculate the maximum sum with out adjacent\n\tint findMaxSum(int *arr, int n) {\n\t    // code here\n\t    vector<int>dp(n+1,-1);\n\t    return solve(arr,n-1,n,dp);\n\t}\n};",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "class Solution{\npublic:\t\nint solve(int *arr, int i,int n,vector<int> &dp){\n    if(i==0){\n        return arr[i];\n    }\n    if(i<0){\n        return 0;\n    }\n    if(dp[i]!=-1){\n        return dp[i];\n    }\n    \n    int pick = arr[i]+solve(arr,i-2,n,dp);\n    int not_pick = 0+solve(arr,i-1,n,dp);\n    \n    return max(pick,not_pick);\n}\n\t// calculate the maximum sum with out adjacent\n\tint findMaxSum(int *arr, int n) {\n\t    // code here\n\t    vector<int>dp(n+1,-1);\n\t    return solve(arr,n-1,n,dp);\n\t}\n};",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 106,
      "versionNonce": 334782159,
      "index": "aB",
      "isDeleted": false,
      "id": "tIB8k3pcAGDdK_slw6g48",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 268.1754826549999,
      "y": 1454.2006982162509,
      "strokeColor": "#2f9e44",
      "backgroundColor": "transparent",
      "width": 459.375,
      "height": 33.6,
      "seed": 1686029469,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1720458443956,
      "link": null,
      "locked": false,
      "fontSize": 28,
      "fontFamily": 3,
      "text": "maximum sum of non adjacent ",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "maximum sum of non adjacent ",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 10,
      "versionNonce": 455145889,
      "index": "aC",
      "isDeleted": false,
      "id": "3VBvKDTEffYZSWKhR_YUo",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 287.0531432621045,
      "y": 2211.8909538032185,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "width": 539.0625,
      "height": 528,
      "seed": 801346547,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1720458443956,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 3,
      "text": "\tint findMaxSum(int *arr, int n) {\n\t    // code here\n\t    int prev = arr[0];\n\t    int prev2 = 0;\n\t    \n\t    for(int i=1;i<n;i++){\n\t        int take = arr[i];\n\t        if(i>1){\n\t            take+=prev2;\n\t        }\n\t        \n\t        int non_take = 0+prev;\n\t        \n\t        int curr = max(take,non_take);\n\t        \n\t        prev2 = prev;\n\t        prev = curr;\n\n\t    }\n\t    \n\t    return prev;\n\t}",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "\tint findMaxSum(int *arr, int n) {\n\t    // code here\n\t    int prev = arr[0];\n\t    int prev2 = 0;\n\t    \n\t    for(int i=1;i<n;i++){\n\t        int take = arr[i];\n\t        if(i>1){\n\t            take+=prev2;\n\t        }\n\t        \n\t        int non_take = 0+prev;\n\t        \n\t        int curr = max(take,non_take);\n\t        \n\t        prev2 = prev;\n\t        prev = curr;\n\n\t    }\n\t    \n\t    return prev;\n\t}",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "type": "rectangle",
      "version": 110,
      "versionNonce": 758536339,
      "index": "aD",
      "isDeleted": false,
      "id": "zm4DwOVbSXhz-53zX_XQm",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 235.97211056095762,
      "y": 1508.6131058383874,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "width": 690.70459392521,
      "height": 1265.9216651247634,
      "seed": 1899609949,
      "groupIds": [],
      "frameId": null,
      "roundness": {
        "type": 3
      },
      "boundElements": [],
      "updated": 1720282346890,
      "link": null,
      "locked": false
    },
    {
      "type": "text",
      "version": 32,
      "versionNonce": 1589488879,
      "index": "aE",
      "isDeleted": false,
      "id": "hqpwwAWSdd7XhdVKrAFC6",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 209.15385904233813,
      "y": 2938.8410818157117,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "width": 996.09375,
      "height": 840,
      "seed": 1563657511,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1720458443956,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 3,
      "text": "class Solution {\n  public:\n  int f(vector<vector<int>>& points, int n,int day,int last,vector<vector<int>> &dp){\n      if(day == 0){\n          int maxi = 0;\n          for(int i=0;i<3;i++){\n              if(last != i){\n                  maxi =max(maxi,points[0][i]);\n              }\n          }\n          return maxi;\n      }\n      \n      if(dp[day][last]!= -1){\n          return dp[day][last];\n      }\n      \n      int maxi = 0;\n      for(int i=0;i<3;i++){\n              if(last != i){\n                  int pt = points[day][i]+f(points,n,day-1,i,dp);\n                  maxi =max(maxi,pt);\n              }\n          }\n          \n    return dp[day][last]=maxi;\n  }\n  \n  int maximumPoints(vector<vector<int>>& points, int n) {\n        // Code here\n        vector<vector<int>>dp(n,vector<int>(4,-1));\n        \n        return f(points,n,n-1,3,dp);\n    }\n};",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "class Solution {\n  public:\n  int f(vector<vector<int>>& points, int n,int day,int last,vector<vector<int>> &dp){\n      if(day == 0){\n          int maxi = 0;\n          for(int i=0;i<3;i++){\n              if(last != i){\n                  maxi =max(maxi,points[0][i]);\n              }\n          }\n          return maxi;\n      }\n      \n      if(dp[day][last]!= -1){\n          return dp[day][last];\n      }\n      \n      int maxi = 0;\n      for(int i=0;i<3;i++){\n              if(last != i){\n                  int pt = points[day][i]+f(points,n,day-1,i,dp);\n                  maxi =max(maxi,pt);\n              }\n          }\n          \n    return dp[day][last]=maxi;\n  }\n  \n  int maximumPoints(vector<vector<int>>& points, int n) {\n        // Code here\n        vector<vector<int>>dp(n,vector<int>(4,-1));\n        \n        return f(points,n,n-1,3,dp);\n    }\n};",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 13,
      "versionNonce": 921902465,
      "index": "aF",
      "isDeleted": false,
      "id": "ZB7ZgscDZNWtapCIu4tPw",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 430.75386514585375,
      "y": 2842.0411275920787,
      "strokeColor": "#2f9e44",
      "backgroundColor": "transparent",
      "width": 82.03125,
      "height": 33.6,
      "seed": 237347017,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1720458443956,
      "link": null,
      "locked": false,
      "fontSize": 28,
      "fontFamily": 3,
      "text": "2D DP",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "2D DP",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 26,
      "versionNonce": 997734159,
      "index": "aH",
      "isDeleted": false,
      "id": "cfaoVuok0UvNGSVQo4epR",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 227.5538529388225,
      "y": 2905.2410879192275,
      "strokeColor": "#1971c2",
      "backgroundColor": "transparent",
      "width": 175.78125,
      "height": 24,
      "seed": 1860595401,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1720458443956,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 3,
      "text": "GEEKS TRAINING ",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "GEEKS TRAINING ",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 3,
      "versionNonce": 298571009,
      "index": "aI",
      "isDeleted": false,
      "id": "E-3VxW-l4dlrJuhbr_Y5N",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 229.953877352885,
      "y": 3861.2411062297742,
      "strokeColor": "#1971c2",
      "backgroundColor": "transparent",
      "width": 984.375,
      "height": 1416,
      "seed": 1935176001,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1720458449633,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 3,
      "text": "--------------------BRUTE FORCE---------------------\nTC: O(2^(N*M))            SC: O(M+N) - path length\n    int f(int n,int m){\n        if(n<0 || m<0) return 0;\n        if(n==0 && m==0) return 1;\n        return f(n-1,m)+f(n,m-1);\n    }\n    int NumberOfPath(int a, int b)\n    {\n        //code here\n        return f(a-1,b-1);\n    }\n\n------------------MEMOIZATION------------------\nTC: O(M*N)                SC: O(M*N)+O(M+N)\n    int f(int n,int m,vector<vector<int>>&dp){\n        if(n<0 || m<0) return 0;\n        if(dp[n][m]!=-1) return dp[n][m];\n        if(n==0 && m==0) return 1;\n        return dp[n][m]=f(n-1,m,dp)+f(n,m-1,dp);\n    }\n    int NumberOfPath(int a, int b)\n    {\n        //code here\n        vector<vector<int>>dp(a,vector<int>(b,-1));\n        return f(a-1,b-1,dp);\n    }\n\n---------------------TABULATION---------------------\nTC: O(M*N)          SC: O(M*N)\n    int NumberOfPath(int n, int m)\n    {\n        //code here\n        vector<vector<int>>dp(n,vector<int>(m,-1));\n        dp[0][0]=1;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(dp[i][j]==-1) dp[i][j] = (i==0?0:dp[i-1][j])+(j==0?0:dp[i][j-1]);\n            }\n        }\n        return dp[n-1][m-1];\n    }\n\n---------------------SPACE OPTIMIZED------------------\nTC: O(M*N)          SC: O(M)\n    int NumberOfPath(int n, int m)\n    {\n        //code here\n        vector<int>v(m,0);\n        for(int i=0;i<n;i++){\n            int prev=0;\n            for(int j=0;j<m;j++){\n                if(i==0 && j==0) prev=1;\n                else prev = prev+v[j];\n                v[j]=prev;\n            }\n        }\n        return v[m-1];\n    }",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "--------------------BRUTE FORCE---------------------\nTC: O(2^(N*M))            SC: O(M+N) - path length\n    int f(int n,int m){\n        if(n<0 || m<0) return 0;\n        if(n==0 && m==0) return 1;\n        return f(n-1,m)+f(n,m-1);\n    }\n    int NumberOfPath(int a, int b)\n    {\n        //code here\n        return f(a-1,b-1);\n    }\n\n------------------MEMOIZATION------------------\nTC: O(M*N)                SC: O(M*N)+O(M+N)\n    int f(int n,int m,vector<vector<int>>&dp){\n        if(n<0 || m<0) return 0;\n        if(dp[n][m]!=-1) return dp[n][m];\n        if(n==0 && m==0) return 1;\n        return dp[n][m]=f(n-1,m,dp)+f(n,m-1,dp);\n    }\n    int NumberOfPath(int a, int b)\n    {\n        //code here\n        vector<vector<int>>dp(a,vector<int>(b,-1));\n        return f(a-1,b-1,dp);\n    }\n\n---------------------TABULATION---------------------\nTC: O(M*N)          SC: O(M*N)\n    int NumberOfPath(int n, int m)\n    {\n        //code here\n        vector<vector<int>>dp(n,vector<int>(m,-1));\n        dp[0][0]=1;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(dp[i][j]==-1) dp[i][j] = (i==0?0:dp[i-1][j])+(j==0?0:dp[i][j-1]);\n            }\n        }\n        return dp[n-1][m-1];\n    }\n\n---------------------SPACE OPTIMIZED------------------\nTC: O(M*N)          SC: O(M)\n    int NumberOfPath(int n, int m)\n    {\n        //code here\n        vector<int>v(m,0);\n        for(int i=0;i<n;i++){\n            int prev=0;\n            for(int j=0;j<m;j++){\n                if(i==0 && j==0) prev=1;\n                else prev = prev+v[j];\n                v[j]=prev;\n            }\n        }\n        return v[m-1];\n    }",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 18,
      "versionNonce": 1039597672,
      "index": "aJ",
      "isDeleted": false,
      "id": "YmLWAr5lHxNUHvLCw1i7y",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 407.5538529388225,
      "y": 3802.0411123332897,
      "strokeColor": "#2f9e44",
      "backgroundColor": "transparent",
      "width": 196.875,
      "height": 33.6,
      "seed": 1574490216,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1720458468833,
      "link": null,
      "locked": false,
      "fontSize": 28,
      "fontFamily": 3,
      "text": "unique paths",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "unique paths",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "type": "text",
      "version": 6,
      "versionNonce": 592905576,
      "index": "aK",
      "isDeleted": false,
      "id": "q3ZWZRJjWzks-zDo65Q91",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "angle": 0,
      "x": 275.5538529388225,
      "y": 5378.841100126258,
      "strokeColor": "#2f9e44",
      "backgroundColor": "transparent",
      "width": 515.625,
      "height": 336,
      "seed": 624097640,
      "groupIds": [],
      "frameId": null,
      "roundness": null,
      "boundElements": [],
      "updated": 1720458768979,
      "link": null,
      "locked": false,
      "fontSize": 20,
      "fontFamily": 3,
      "text": "int dp[a][b];\n        dp[0][0]=1;\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                int up=0,left=0;\n                if(i==0&&j==0) dp[i][j]= 1;\n                else {\n                    if(i>0) up=dp[i-1][j];\n                    if(j>0) left=dp[i][j-1];\n                    dp[i][j]=up + left;\n                }\n            }\n        }\n        return dp[a-1][b-1] ;",
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "int dp[a][b];\n        dp[0][0]=1;\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                int up=0,left=0;\n                if(i==0&&j==0) dp[i][j]= 1;\n                else {\n                    if(i>0) up=dp[i-1][j];\n                    if(j>0) left=dp[i][j-1];\n                    dp[i][j]=up + left;\n                }\n            }\n        }\n        return dp[a-1][b-1] ;",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "id": "Wvmvv32h2amhfZWcK2NYn",
      "type": "text",
      "x": 216.35387124936938,
      "y": 5781.241106229774,
      "width": 175.78125,
      "height": 24,
      "angle": 0,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aL",
      "roundness": null,
      "seed": 657146150,
      "version": 24,
      "versionNonce": 1195219942,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1720713611283,
      "link": null,
      "locked": false,
      "text": "MAZE OBSTACLES ",
      "fontSize": 20,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "MAZE OBSTACLES ",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "id": "humRPxf8CYz3_-tiim3G6",
      "type": "text",
      "x": 242.75386514585375,
      "y": 5861.241106229774,
      "width": 808.59375,
      "height": 576,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aM",
      "roundness": null,
      "seed": 1120757498,
      "version": 3,
      "versionNonce": 424112250,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1720713618202,
      "link": null,
      "locked": false,
      "text": "class Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m = obstacleGrid.size();\n        int n = obstacleGrid[0].size();\n        vector<vector<int>> dp(m, vector<int>(n, 0));\n        \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (obstacleGrid[i][j] == 1) {\n                    dp[i][j] = 0;\n                } else if (i == 0 && j == 0) {\n                    dp[i][j] = 1;\n                } else {\n                    int up = (i > 0) ? dp[i-1][j] : 0;\n                    int left = (j > 0) ? dp[i][j-1] : 0;\n                    dp[i][j] = up + left;\n                }\n            }\n        }\n        \n        return dp[m-1][n-1];\n    }\n};",
      "fontSize": 20,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "class Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m = obstacleGrid.size();\n        int n = obstacleGrid[0].size();\n        vector<vector<int>> dp(m, vector<int>(n, 0));\n        \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (obstacleGrid[i][j] == 1) {\n                    dp[i][j] = 0;\n                } else if (i == 0 && j == 0) {\n                    dp[i][j] = 1;\n                } else {\n                    int up = (i > 0) ? dp[i-1][j] : 0;\n                    int left = (j > 0) ? dp[i][j-1] : 0;\n                    dp[i][j] = up + left;\n                }\n            }\n        }\n        \n        return dp[m-1][n-1];\n    }\n};",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "id": "dnAkMgcBtqX_ynN5jNDhv",
      "type": "text",
      "x": 250.75386514585375,
      "y": 6487.641100126259,
      "width": 960.9375,
      "height": 504,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aN",
      "roundness": null,
      "seed": 797252262,
      "version": 3,
      "versionNonce": 1515137318,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1720713646547,
      "link": null,
      "locked": false,
      "text": "class Solution {\npublic:\n\n   int fun(vector<vector<int>>& dp,vector<vector<int>>& obstacleGrid,int i,int j){\n        if(i<0 || j<0 || (obstacleGrid[i][j]==1)) return 0;\n        if(i==0 && j==0) return 1;\n        if(dp[i][j]!=-1) return dp[i][j];\n\n        int left = fun(dp,obstacleGrid,i-1,j);\n        int up = fun(dp,obstacleGrid,i,j-1);\n\n        return dp[i][j]=left+up;\n   }\n\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m=obstacleGrid.size();\n        int n=obstacleGrid[0].size();\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return fun(dp,obstacleGrid,m-1,n-1);\n    }\n};",
      "fontSize": 20,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "class Solution {\npublic:\n\n   int fun(vector<vector<int>>& dp,vector<vector<int>>& obstacleGrid,int i,int j){\n        if(i<0 || j<0 || (obstacleGrid[i][j]==1)) return 0;\n        if(i==0 && j==0) return 1;\n        if(dp[i][j]!=-1) return dp[i][j];\n\n        int left = fun(dp,obstacleGrid,i-1,j);\n        int up = fun(dp,obstacleGrid,i,j-1);\n\n        return dp[i][j]=left+up;\n   }\n\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m=obstacleGrid.size();\n        int n=obstacleGrid[0].size();\n        vector<vector<int>> dp(m,vector<int>(n,-1));\n        return fun(dp,obstacleGrid,m-1,n-1);\n    }\n};",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "id": "zvYjSakfYKCPXip0XmUy7",
      "type": "text",
      "x": 260.3538712493694,
      "y": 7121.241090970985,
      "width": 281.25,
      "height": 72,
      "angle": 0,
      "strokeColor": "#e03131",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aO",
      "roundness": null,
      "seed": 802580006,
      "version": 28,
      "versionNonce": 7847398,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1720715767249,
      "link": null,
      "locked": false,
      "text": "minimum sum of the path \n\n",
      "fontSize": 20,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "minimum sum of the path \n\n",
      "autoResize": true,
      "lineHeight": 1.2
    },
    {
      "id": "5zRA9O60TxEWxPuRDhlHF",
      "type": "text",
      "x": 248.35387124936938,
      "y": 7198.84111233329,
      "width": 691.40625,
      "height": 576,
      "angle": 0,
      "strokeColor": "#f08c00",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "aP",
      "roundness": null,
      "seed": 1704387834,
      "version": 3,
      "versionNonce": 1514761850,
      "isDeleted": false,
      "boundElements": null,
      "updated": 1720715775567,
      "link": null,
      "locked": false,
      "text": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int n =grid.size();\n        int m = grid[0].size();\n        int dp[n][m];\n        for(int i=0;i<n;i++){\n            for(int j = 0;j<m;j++){\n                if(i==0 && j==0){\n                    dp[i][j] = grid[0][0];\n                }\n                else{\n                    int  up,left;\n                    if(i>0) up = grid[i][j] + dp[i-1][j];\n                    else up = grid[i][j] + 1e9;\n                    if(j>0) left = grid[i][j] + dp[i][j-1];\n                    else left = grid[i][j] + 1e9;\n                    dp[i][j] = min(up,left);\n                }\n            }\n        }\n        return dp[n-1][m-1];\n    }\n};",
      "fontSize": 20,
      "fontFamily": 3,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int n =grid.size();\n        int m = grid[0].size();\n        int dp[n][m];\n        for(int i=0;i<n;i++){\n            for(int j = 0;j<m;j++){\n                if(i==0 && j==0){\n                    dp[i][j] = grid[0][0];\n                }\n                else{\n                    int  up,left;\n                    if(i>0) up = grid[i][j] + dp[i-1][j];\n                    else up = grid[i][j] + 1e9;\n                    if(j>0) left = grid[i][j] + dp[i][j-1];\n                    else left = grid[i][j] + 1e9;\n                    dp[i][j] = min(up,left);\n                }\n            }\n        }\n        return dp[n-1][m-1];\n    }\n};",
      "autoResize": true,
      "lineHeight": 1.2
    }
  ],
  "appState": {
    "gridSize": null,
    "viewBackgroundColor": "#ffffff"
  },
  "files": {}
}